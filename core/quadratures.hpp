/*
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Toy implememtation of Discontinuous Galerkin for teaching purposes
 *
 * Matteo Cicuttin (c) 2018
 */

/*
 *       /\        Matteo Cicuttin (C) 2016, 2017, 2018
 *      /__\       matteo.cicuttin@enpc.fr
 *     /_\/_\      École Nationale des Ponts et Chaussées - CERMICS
 *    /\    /\
 *   /__\  /__\    DISK++, a template library for DIscontinuous SKeletal
 *  /_\/_\/_\/_\   methods.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * If you use this code or parts of it for scientific publications, you
 * are required to cite it as following:
 *
 * Implementation of Discontinuous Skeletal methods on arbitrary-dimensional,
 * polytopal meshes using generic programming.
 * M. Cicuttin, D. A. Di Pietro, A. Ern.
 * Journal of Computational and Applied Mathematics.
 * DOI: 10.1016/j.cam.2017.09.017
 */

#pragma once

#include <vector>
#include <cmath>

#include "core/point.hpp"
#include "core/mesh.hpp"
#include "core/refelem.hpp"

#define USE_DUNAVANT

namespace yaourt {
namespace quadratures {


template<typename T, size_t DIM>
class quadrature_point
{
    point<T,DIM>    q_point;
    T               q_weight;

public:
    typedef point<T,DIM>    point_type;
    typedef T               weight_type;

    quadrature_point()
    {}

    quadrature_point(const point_type& qp, const weight_type& qw)
        : q_point(qp), q_weight(qw)
    {}

    auto point() const { return q_point; }
    auto weight() const { return q_weight; }
};

template<typename T, size_t DIM>
auto make_qp(const point<T, DIM>& qp, const T& qw)
{
    return quadrature_point<T, DIM>(qp, qw);
}


/* Gauss-Legendre 1D quadrature. */
template<typename T>
std::vector<std::pair<point<T, 1>, T>>
gauss_legendre_old(size_t degree)
{
    std::vector<std::pair<point<T, 1>, T>> ret;

    point<T, 1> qp;
    T           qw;
    T           a1, a2;

    switch (degree)
    {
        case 0:
        case 1:
            qp = point<T, 1>({0.0});
            qw = 2.0;
            ret.push_back(std::make_pair(qp, qw));
            return ret;

        case 2:
        case 3:
            qp = point<T, 1>({1.0 / std::sqrt(3.0)});
            qw = 1.0;
            ret.push_back(std::make_pair(-qp, qw));
            ret.push_back(std::make_pair(qp, qw));
            return ret;

        case 4:
        case 5:
            qp = point<T, 1>({std::sqrt(3.0 / 5.0)});
            qw = 5.0 / 9.0;
            ret.push_back(std::make_pair(-qp, qw));
            ret.push_back(std::make_pair(qp, qw));

            qp = point<T, 1>({0.0});
            qw = 8.0 / 9.0;
            ret.push_back(std::make_pair(qp, qw));

            return ret;

        case 6:
        case 7:
            a1 = 15;
            a2 = 2.0 * std::sqrt(30.0);

            qp = point<T, 1>({std::sqrt((a1 - a2) / 35.0)});
            qw = (18.0 + std::sqrt(30.0)) / 36.0;
            ret.push_back(std::make_pair(-qp, qw));
            ret.push_back(std::make_pair(qp, qw));

            qp = point<T, 1>({std::sqrt((a1 + a2) / 35.0)});
            qw = (18.0 - std::sqrt(30.0)) / 36.0;
            ret.push_back(std::make_pair(-qp, qw));
            ret.push_back(std::make_pair(qp, qw));

            return ret;

        case 8:
        case 9:
            qp = point<T, 1>({0.0});
            qw = 128.0 / 225.0;
            ret.push_back(std::make_pair(qp, qw));

            a1 = 5.0;
            a2 = 2.0 * std::sqrt(10.0 / 7.0);
            qp = point<T, 1>({std::sqrt(a1 - a2) / 3.0});
            qw = (322 + 13.0 * std::sqrt(70.0)) / 900.0;
            ret.push_back(std::make_pair(-qp, qw));
            ret.push_back(std::make_pair(qp, qw));

            qp = point<T, 1>({std::sqrt(a1 + a2) / 3.0});
            qw = (322 - 13.0 * std::sqrt(70.0)) / 900.0;
            ret.push_back(std::make_pair(-qp, qw));
            ret.push_back(std::make_pair(qp, qw));
            return ret;

        default:
            throw std::invalid_argument("Gauss quadrature: degree too high");
    }

    return ret;
}


namespace detail {


/* Automatically generated by mkgauss.cpp */

struct gauss_point {
    double point;
    double weight;
};

/* 1-point Gauss rule */
static gauss_point gauss_rule_1[] = {
    {                        0,                        2 }
};

/* 2-point Gauss rule */
static gauss_point gauss_rule_2[] = {
    {       -0.577350269189626,                        1 },
    {        0.577350269189626,                        1 }
};

/* 3-point Gauss rule */
static gauss_point gauss_rule_3[] = {
    {       -0.774596669241483,        0.555555555555556 },
    {                        0,        0.888888888888889 },
    {        0.774596669241483,        0.555555555555556 }
};

/* 4-point Gauss rule */
static gauss_point gauss_rule_4[] = {
    {       -0.861136311594053,        0.347854845137454 },
    {       -0.339981043584856,        0.652145154862546 },
    {        0.339981043584856,        0.652145154862546 },
    {        0.861136311594052,        0.347854845137453 }
};

/* 5-point Gauss rule */
static gauss_point gauss_rule_5[] = {
    {       -0.906179845938664,        0.236926885056189 },
    {       -0.538469310105683,        0.478628670499366 },
    {                        0,        0.568888888888889 },
    {        0.538469310105683,        0.478628670499367 },
    {        0.906179845938664,        0.236926885056189 }
};

/* 6-point Gauss rule */
static gauss_point gauss_rule_6[] = {
    {       -0.932469514203152,         0.17132449237917 },
    {       -0.661209386466264,        0.360761573048138 },
    {       -0.238619186083197,        0.467913934572691 },
    {        0.238619186083197,        0.467913934572691 },
    {        0.661209386466264,        0.360761573048138 },
    {        0.932469514203152,        0.171324492379171 }
};

/* 7-point Gauss rule */
static gauss_point gauss_rule_7[] = {
    {       -0.949107912342759,         0.12948496616887 },
    {       -0.741531185599394,        0.279705391489276 },
    {       -0.405845151377397,        0.381830050505119 },
    {                        0,        0.417959183673469 },
    {        0.405845151377397,        0.381830050505119 },
    {        0.741531185599394,        0.279705391489276 },
    {        0.949107912342758,         0.12948496616887 }
};

/* 8-point Gauss rule */
static gauss_point gauss_rule_8[] = {
    {       -0.960289856497536,        0.101228536290376 },
    {       -0.796666477413627,        0.222381034453375 },
    {       -0.525532409916329,        0.313706645877887 },
    {        -0.18343464249565,        0.362683783378362 },
    {         0.18343464249565,        0.362683783378362 },
    {        0.525532409916329,        0.313706645877888 },
    {        0.796666477413627,        0.222381034453374 },
    {        0.960289856497536,        0.101228536290377 }
};

/* 9-point Gauss rule */
static gauss_point gauss_rule_9[] = {
    {       -0.968160239507626,       0.0812743883615746 },
    {       -0.836031107326636,        0.180648160694858 },
    {        -0.61337143270059,        0.260610696402936 },
    {       -0.324253423403809,        0.312347077040003 },
    {                        0,         0.33023935500126 },
    {        0.324253423403809,        0.312347077040003 },
    {        0.613371432700591,        0.260610696402936 },
    {        0.836031107326637,        0.180648160694857 },
    {        0.968160239507627,       0.0812743883615752 }
};

/* 10-point Gauss rule */
static gauss_point gauss_rule_10[] = {
    {       -0.973906528517171,       0.0666713443086882 },
    {       -0.865063366688984,         0.14945134915058 },
    {       -0.679409568299024,        0.219086362515982 },
    {       -0.433395394129247,        0.269266719309996 },
    {       -0.148874338981631,        0.295524224714753 },
    {        0.148874338981631,        0.295524224714753 },
    {        0.433395394129247,        0.269266719309997 },
    {        0.679409568299025,        0.219086362515982 },
    {        0.865063366688985,        0.149451349150582 },
    {        0.973906528517172,       0.0666713443086878 }
};

struct gauss_rule {
    size_t          num_entries;
    gauss_point     *points;
};


static struct gauss_rule gauss_rules[] = {
    {  sizeof(gauss_rule_1)/(sizeof(gauss_point)), gauss_rule_1  },
    {  sizeof(gauss_rule_2)/(sizeof(gauss_point)), gauss_rule_2  },
    {  sizeof(gauss_rule_3)/(sizeof(gauss_point)), gauss_rule_3  },
    {  sizeof(gauss_rule_4)/(sizeof(gauss_point)), gauss_rule_4  },
    {  sizeof(gauss_rule_5)/(sizeof(gauss_point)), gauss_rule_5  },
    {  sizeof(gauss_rule_6)/(sizeof(gauss_point)), gauss_rule_6  },
    {  sizeof(gauss_rule_7)/(sizeof(gauss_point)), gauss_rule_7  },
    {  sizeof(gauss_rule_8)/(sizeof(gauss_point)), gauss_rule_8  },
    {  sizeof(gauss_rule_9)/(sizeof(gauss_point)), gauss_rule_9  },
    { sizeof(gauss_rule_10)/(sizeof(gauss_point)), gauss_rule_10 },
    { 0, NULL }
};

template<typename T>
std::vector<std::pair<point<T, 1>, T>>
gauss_legendre_tab(size_t degree)
{
    auto rule_num = degree/2;
    auto num_entries = gauss_rules[rule_num].num_entries;
    std::vector<std::pair<point<T, 1>, T>> ret;
    ret.reserve(num_entries);
    for (size_t i = 0; i < num_entries; i++)
    {
        auto &qp = gauss_rules[rule_num].points[i];
        ret.push_back( {qp.point, qp.weight} );
    }

    return ret;
}


struct dunavant_point {
    size_t      perms;
    double      coords[3];
    double      weight;
};

static dunavant_point dunavant_rule_1[] = {
    { 1, { 0.333333333333333, 0.333333333333333, 0.333333333333333 },  1.000000000000000 }
};

static dunavant_point dunavant_rule_2[] = {
    { 3, { 0.666666666666667, 0.166666666666667, 0.166666666666667 },  0.333333333333333 }
};

static dunavant_point dunavant_rule_3[] = {
    { 1, { 0.333333333333333, 0.333333333333333, 0.333333333333333 }, -0.562500000000000 },
    { 3, { 0.600000000000000, 0.200000000000000, 0.200000000000000 },  0.520833333333333 }
};

static dunavant_point dunavant_rule_4[] = {
    { 3, { 0.108103018168070, 0.445948490915965, 0.445948490915965 },  0.223381589678011 },
    { 3, { 0.816847572980459, 0.091576213509771, 0.091576213509771 },  0.109951743655322 }
};

static dunavant_point dunavant_rule_5[] = {
    { 1, { 0.333333333333333, 0.333333333333333, 0.333333333333333 },  0.225000000000000 },
    { 3, { 0.059715871789770, 0.470142064105115, 0.470142064105115 },  0.132394152788506 },
    { 3, { 0.797426985353087, 0.101286507323456, 0.101286507323456 },  0.125939180544827 }
};

static dunavant_point dunavant_rule_6[] = {
    { 3, { 0.501426509658179, 0.249286745170910, 0.249286745170910 },  0.116786275726379 },
    { 3, { 0.873821971016996, 0.063089014491502, 0.063089014491502 },  0.050844906370207 },
    { 6, { 0.053145049844817, 0.310352451033784, 0.636502499121399 },  0.082851075618374 }
};

static dunavant_point dunavant_rule_7[] = {
    { 1, { 0.333333333333333, 0.333333333333333, 0.333333333333333 }, -0.149570044467682 },
    { 3, { 0.479308067841920, 0.260345966079040, 0.260345966079040 },  0.175615257433208 },
    { 3, { 0.869739794195568, 0.065130102902216, 0.065130102902216 },  0.053347235608838 },
    { 6, { 0.048690315425316, 0.312865496004874, 0.638444188569810 },  0.077113760890257 },
};

static dunavant_point dunavant_rule_8[] = {
    { 1, { 0.333333333333333, 0.333333333333333, 0.333333333333333 },  0.144315607677787 },
    { 3, { 0.081414823414554, 0.459292588292723, 0.459292588292723 },  0.095091634267285 },
    { 3, { 0.658861384496480, 0.170569307751760, 0.170569307751760 },  0.103217370534718 },
    { 3, { 0.898905543365938, 0.050547228317031, 0.050547228317031 },  0.032458497623198 },
    { 6, { 0.008394777409958, 0.263112829634638, 0.728492392955404 },  0.027230314174435 }
};

static dunavant_point dunavant_rule_9[] = {
    { 1, { 0.333333333333333, 0.333333333333333, 0.333333333333333 },  0.097135796282799 },
    { 3, { 0.020634961602525, 0.489682519198738, 0.489682519198738 },  0.031334700227139 },
    { 3, { 0.125820817014127, 0.437089591492937, 0.437089591492937 },  0.077827541004774 },
    { 3, { 0.623592928761935, 0.188203535619033, 0.188203535619033 },  0.079647738927210 },
    { 3, { 0.910540973211095, 0.044729513394453, 0.044729513394453 },  0.025577675658698 },
    { 6, { 0.036838412054736, 0.221962989160766, 0.741198598784498 },  0.043283539377289 }
};

static dunavant_point dunavant_rule_10[] = {
    { 1, { 0.333333333333333, 0.333333333333333, 0.333333333333333 },  0.090817990382754 },
    { 3, { 0.028844733232685, 0.485577633383657, 0.485577633383657 },  0.036725957756467 },
    { 3, { 0.781036849029926, 0.109481575485037, 0.109481575485037 },  0.045321059435528 },
    { 6, { 0.141707219414880, 0.307939838764121, 0.550352941820999 },  0.072757916845420 },
    { 6, { 0.025003534762686, 0.246672560639903, 0.728323904597411 },  0.028327242531057 },
    { 6, { 0.009540815400299, 0.066803251012200, 0.923655933587500 },  0.009421666963733 }
};

static dunavant_point dunavant_rule_11[] = {
    { 3, {-0.069222096541517, 0.534611048270758, 0.534611048270758 },  0.000927006328961 },
    { 3, { 0.202061394068290, 0.398969302965855, 0.398969302965855 },  0.077149534914813 },
    { 3, { 0.593380199137435, 0.203309900431282, 0.203309900431282 },  0.059322977380774 },
    { 3, { 0.761298175434837, 0.119350912282581, 0.119350912282581 },  0.036184540503418 },
    { 3, { 0.935270103777448, 0.032364948111276, 0.032364948111276 },  0.013659731002678 },
    { 6, { 0.050178138310495, 0.356620648261293, 0.593201213428213 },  0.052337111962204 },
    { 6, { 0.021022016536166, 0.171488980304042, 0.807489003159792 },  0.020707659639141 }
};

static dunavant_point dunavant_rule_12[] = {
    { 3, { 0.023565220452390, 0.488217389773805, 0.488217389773805 },  0.025731066440455 },
    { 3, { 0.120551215411079, 0.439724392294460, 0.439724392294460 },  0.043692544538038 },
    { 3, { 0.457579229975768, 0.271210385012116, 0.271210385012116 },  0.062858224217885 },
    { 3, { 0.744847708916828, 0.127576145541586, 0.127576145541586 },  0.034796112930709 },
    { 3, { 0.957365299093579, 0.021317350453210, 0.021317350453210 },  0.006166261051559 },
    { 6, { 0.115343494534698, 0.275713269685514, 0.608943235779788 },  0.040371557766381 },
    { 6, { 0.022838332222257, 0.281325580989940, 0.695836086787803 },  0.022356773202303 },
    { 6, { 0.025734050548330, 0.116251915907597, 0.858014033544073 },  0.017316231108659 }
};
    
static dunavant_point dunavant_rule_13[] = {
    { 1, { 0.333333333333333, 0.333333333333333, 0.333333333333333 },  0.052520923400802 },
    { 3, { 0.009903630120591, 0.495048184939705, 0.495048184939705 },  0.011280145209330 },
    { 3, { 0.062566729780852, 0.468716635109574, 0.468716635109574 },  0.031423518362454 },
    { 3, { 0.170957326397447, 0.414521336801277, 0.414521336801277 },  0.047072502504194 },
    { 3, { 0.541200855914337, 0.229399572042831, 0.229399572042831 },  0.047363586536355 },
    { 3, { 0.771151009607340, 0.114424495196330, 0.114424495196330 },  0.031167529045794 },
    { 3, { 0.950377217273082, 0.024811391363459, 0.024811391363459 },  0.007975771465074 },
    { 6, { 0.094853828379579, 0.268794997058761, 0.636351174561660 },  0.036848402728732 },
    { 6, { 0.018100773278807, 0.291730066734288, 0.690169159986905 },  0.017401463303822 },
    { 6, { 0.022233076674090, 0.126357385491669, 0.851409537834241 },  0.015521786839045 }
};

static dunavant_point dunavant_rule_14[] = {
    { 3, { 0.022072179275643, 0.488963910362179, 0.488963910362179 },  0.021883581369429 },
    { 3, { 0.164710561319092, 0.417644719340454, 0.417644719340454 },  0.032788353544125 },
    { 3, { 0.453044943382323, 0.273477528308839, 0.273477528308839 },  0.051774104507292 },
    { 3, { 0.645588935174913, 0.177205532412543, 0.177205532412543 },  0.042162588736993 },
    { 3, { 0.876400233818255, 0.061799883090873, 0.061799883090873 },  0.014433699669777 },
    { 3, { 0.961218077502598, 0.019390961248701, 0.019390961248701 },  0.004923403602400 },
    { 6, { 0.057124757403648, 0.172266687821356, 0.770608554774996 },  0.024665753212564 },
    { 6, { 0.092916249356972, 0.336861459796345, 0.570222290846683 },  0.038571510787061 },
    { 6, { 0.014646950055654, 0.298372882136258, 0.686980167808088 },  0.014436308113534 },
    { 6, { 0.001268330932872, 0.118974497696957, 0.879757171370171 },  0.005010228838501 }
};

static dunavant_point dunavant_rule_15[] = {
    { 3, {-0.013945833716486, 0.506972916858243, 0.506972916858243 },  0.001916875642849 },
    { 3, { 0.137187291433955, 0.431406354283023, 0.431406354283023 },  0.044249027271145 },
    { 3, { 0.444612710305711, 0.277693644847144, 0.277693644847144 },  0.051186548718852 },
    { 3, { 0.747070217917492, 0.126464891041254, 0.126464891041254 },  0.023687735870688 },
    { 3, { 0.858383228050628, 0.070808385974686, 0.070808385974686 },  0.013289775690021 },
    { 3, { 0.962069659517853, 0.018965170241073, 0.018965170241073 },  0.004748916608192 },
    { 6, { 0.133734161966621, 0.261311371140087, 0.604954466893291 },  0.038550072599593 },
    { 6, { 0.036366677396917, 0.388046767090269, 0.575586555512814 },  0.027215814320624 },
    { 6, {-0.010174883126571, 0.285712220049916, 0.724462663076655 },  0.002182077366797 },
    { 6, { 0.036843869875878, 0.215599664072284, 0.747556466051838 },  0.021505319847731 },
    { 6, { 0.012459809331199, 0.103575616576386, 0.883964574092416 },  0.007673942631049 }
};

static dunavant_point dunavant_rule_16[] = {
    { 1, { 0.333333333333333, 0.333333333333333, 0.333333333333333 },  0.046875697427642 },
    { 3, { 0.005238916103123, 0.497380541948438, 0.497380541948438 },  0.006405878578585 },
    { 3, { 0.173061122901295, 0.413469438549352, 0.413469438549352 },  0.041710296739387 },
    { 3, { 0.059082801866017, 0.470458599066991, 0.470458599066991 },  0.026891484250064 },
    { 3, { 0.518892500060958, 0.240553749969521, 0.240553749969521 },  0.042132522761650 },
    { 3, { 0.704068411554854, 0.147965794222573, 0.147965794222573 },  0.030000266842773 },
    { 3, { 0.849069624685052, 0.075465187657474, 0.075465187657474 },  0.014200098925024 },
    { 3, { 0.966807194753950, 0.016596402623025, 0.016596402623025 },  0.003582462351273 },
    { 6, { 0.103575692245252, 0.296555596579887, 0.599868711174861 },  0.032773147460627 },
    { 6, { 0.020083411655416, 0.337723063403079, 0.642193524941505 },  0.015298306248441 },
    { 6, {-0.004341002614139, 0.204748281642812, 0.799592720971327 },  0.002386244192839 },
    { 6, { 0.041941786468010, 0.189358492130623, 0.768699721401368 },  0.019084792755899 },
    { 6, { 0.014317320230681, 0.085283615682657, 0.900399064086661 },  0.006850054546542 }
};

static dunavant_point dunavant_rule_17[] = {
    { 1, { 0.333333333333333, 0.333333333333333, 0.333333333333333 },  0.033437199290803 },
    { 3, { 0.005658918886452, 0.497170540556774, 0.497170540556774 },  0.005093415440507 },
    { 3, { 0.035647354750751, 0.482176322624625, 0.482176322624625 },  0.014670864527638 },
    { 3, { 0.099520061958437, 0.450239969020782, 0.450239969020782 },  0.024350878353672 },
    { 3, { 0.199467521245206, 0.400266239377397, 0.400266239377397 },  0.031107550868969 },
    { 3, { 0.495717464058095, 0.252141267970953, 0.252141267970953 },  0.031257111218620 },
    { 3, { 0.675905990683077, 0.162047004658461, 0.162047004658461 },  0.024815654339665 },
    { 3, { 0.848248235478508, 0.075875882260746, 0.075875882260746 },  0.014056073070557 },
    { 3, { 0.968690546064356, 0.015654726967822, 0.015654726967822 },  0.003194676173779 },
    { 6, { 0.010186928826919, 0.334319867363658, 0.655493203809423 },  0.008119655318993 },
    { 6, { 0.135440871671036, 0.292221537796944, 0.572337590532020 },  0.026805742283163 },
    { 6, { 0.054423924290583, 0.319574885423190, 0.626001190286228 },  0.018459993210822 },
    { 6, { 0.012868560833637, 0.190704224192292, 0.796427214974071 },  0.008476868534328 },
    { 6, { 0.067165782413524, 0.180483211648746, 0.752351005937729 },  0.018292796770025 },
    { 6, { 0.014663182224828, 0.080711313679564, 0.904625504095608 },  0.006665632004165 }
};

static dunavant_point dunavant_rule_18[] = {
    { 1, { 0.333333333333333, 0.333333333333333, 0.333333333333333 },  0.030809939937647 },
    { 3, { 0.013310382738157, 0.493344808630921, 0.493344808630921 },  0.009072436679404 },
    { 3, { 0.061578811516086, 0.469210594241957, 0.469210594241957 },  0.018761316939594 },
    { 3, { 0.127437208225989, 0.436281395887006, 0.436281395887006 },  0.019441097985477 },
    { 3, { 0.210307658653168, 0.394846170673416, 0.394846170673416 },  0.027753948610810 },
    { 3, { 0.500410862393686, 0.249794568803157, 0.249794568803157 },  0.032256225351457 },
    { 3, { 0.677135612512315, 0.161432193743843, 0.161432193743843 },  0.025074032616922 },
    { 3, { 0.846803545029257, 0.076598227485371, 0.076598227485371 },  0.015271927971832 },
    { 3, { 0.951495121293100, 0.024252439353450, 0.024252439353450 },  0.006793922022963 },
    { 3, { 0.913707265566071, 0.043146367216965, 0.043146367216965 }, -0.002223098729920 },
    { 6, { 0.008430536202420, 0.358911494940944, 0.632657968856636 },  0.006331914076406 },
    { 6, { 0.131186551737188, 0.294402476751957, 0.574410971510855 },  0.027257538049138 },
    { 6, { 0.050203151565675, 0.325017801641814, 0.624779046792512 },  0.017676785649465 },
    { 6, { 0.066329263810916, 0.184737559666046, 0.748933176523037 },  0.018379484638070 },
    { 6, { 0.011996194566236, 0.218796800013321, 0.769207005420443 },  0.008104732808192 },
    { 6, { 0.014858100590125, 0.101179597136408, 0.883962302273467 },  0.007634129070725 },
    { 6, {-0.035222015287949, 0.020874755282586, 1.014347260005363 },  0.000046187660794 }
};

static dunavant_point dunavant_rule_19[] = {
    { 1, { 0.333333333333333, 0.333333333333333, 0.333333333333333 },  0.032906331388919 },
    { 3, { 0.020780025853987, 0.489609987073006, 0.489609987073006 },  0.010330731891272 },
    { 3, { 0.090926214604215, 0.454536892697893, 0.454536892697893 },  0.022387247263016 },
    { 3, { 0.197166638701138, 0.401416680649431, 0.401416680649431 },  0.030266125869468 },
    { 3, { 0.488896691193805, 0.255551654403098, 0.255551654403098 },  0.030490967802198 },
    { 3, { 0.645844115695741, 0.177077942152130, 0.177077942152130 },  0.024159212741641 },
    { 3, { 0.779877893544096, 0.110061053227952, 0.110061053227952 },  0.016050803586801 },
    { 3, { 0.888942751496321, 0.055528624251840, 0.055528624251840 },  0.008084580261784 },
    { 3, { 0.974756272445543, 0.012621863777229, 0.012621863777229 },  0.002079362027485 },
    { 6, { 0.003611417848412, 0.395754787356943, 0.600633794794645 },  0.003884876904981 },
    { 6, { 0.134466754530780, 0.307929983880436, 0.557603261588784 },  0.025574160612022 },
    { 6, { 0.014446025776115, 0.264566948406520, 0.720987025817365 },  0.008880903573338 },
    { 6, { 0.046933578838178, 0.358539352205951, 0.594527068955871 },  0.016124546761731 },
    { 6, { 0.002861120350567, 0.157807405968595, 0.839331473680839 },  0.002491941817491 },
    { 6, { 0.223861424097916, 0.075050596975911, 0.701087978926173 },  0.018242840118951 },
    { 6, { 0.034647074816760, 0.142421601113383, 0.822931324069857 },  0.010258563736199 },
    { 6, { 0.010161119296278, 0.065494628082938, 0.924344252620784 },  0.003799928855302 }
}; 
     
static dunavant_point dunavant_rule_20[] = {
    { 1, { 0.333333333333333, 0.333333333333333, 0.333333333333333 }, 0.033057055541624 },
    { 3, {-0.001900928704400, 0.500950464352200, 0.500950464352200 }, 0.000867019185663 },
    { 3, { 0.023574084130543, 0.488212957934729, 0.488212957934729 }, 0.011660052716448 },
    { 3, { 0.089726636099435, 0.455136681950283, 0.455136681950283 }, 0.022876936356421 },
    { 3, { 0.196007481363421, 0.401996259318289, 0.401996259318289 }, 0.030448982673938 },
    { 3, { 0.488214180481157, 0.255892909759421, 0.255892909759421 }, 0.030624891725355 },
    { 3, { 0.647023488009788, 0.176488255995106, 0.176488255995106 }, 0.024368057676800 },
    { 3, { 0.791658289326483, 0.104170855336758, 0.104170855336758 }, 0.015997432032024 },
    { 3, { 0.893862072318140, 0.053068963840930, 0.053068963840930 }, 0.007698301815602 },
    { 3, { 0.916762569607942, 0.041618715196029, 0.041618715196029 }, 0.000632060497488 },
    { 3, { 0.976836157186356, 0.011581921406822, 0.011581921406822 }, 0.001751134301193 },
    { 6, { 0.048741583664839, 0.344855770229001, 0.606402646106160 }, 0.016465839189576 },
    { 6, { 0.006314115948605, 0.377843269594854, 0.615842614456541 }, 0.004839033540485 },
    { 6, { 0.134316520547348, 0.306635479062357, 0.559048000390295 }, 0.025804906534650 },
    { 6, { 0.013973893962392, 0.249419362774742, 0.736606743262866 }, 0.008471091054441 },
    { 6, { 0.075549132909764, 0.212775724802802, 0.711675142287434 }, 0.018354914106280 },
    { 6, {-0.008368153208227, 0.146965436053239, 0.861402717154987 }, 0.000704404677908 },
    { 6, { 0.026686063258714, 0.137726978828923, 0.835586957912363 }, 0.010112684927462 },
    { 6, { 0.010547719294141, 0.059696109149007, 0.929756171556853 }, 0.003573909385950 }
};   

struct dunavant_rule {
    size_t          num_entries;
    size_t          num_points;
    dunavant_point  *points;
};

static struct dunavant_rule dunavant_rules[] = {
    {  sizeof(dunavant_rule_1)/(sizeof(dunavant_point)),  1, dunavant_rule_1  },
    {  sizeof(dunavant_rule_2)/(sizeof(dunavant_point)),  3, dunavant_rule_2  },
    {  sizeof(dunavant_rule_3)/(sizeof(dunavant_point)),  4, dunavant_rule_3  },
    {  sizeof(dunavant_rule_4)/(sizeof(dunavant_point)),  6, dunavant_rule_4  },
    {  sizeof(dunavant_rule_5)/(sizeof(dunavant_point)),  7, dunavant_rule_5  },
    {  sizeof(dunavant_rule_6)/(sizeof(dunavant_point)), 12, dunavant_rule_6  },
    {  sizeof(dunavant_rule_7)/(sizeof(dunavant_point)), 13, dunavant_rule_7  },
    {  sizeof(dunavant_rule_8)/(sizeof(dunavant_point)), 16, dunavant_rule_8  },
    {  sizeof(dunavant_rule_9)/(sizeof(dunavant_point)), 19, dunavant_rule_9  },
    { sizeof(dunavant_rule_10)/(sizeof(dunavant_point)), 25, dunavant_rule_10 },
    { sizeof(dunavant_rule_11)/(sizeof(dunavant_point)), 27, dunavant_rule_11 },
    { sizeof(dunavant_rule_12)/(sizeof(dunavant_point)), 33, dunavant_rule_12 },
    { sizeof(dunavant_rule_13)/(sizeof(dunavant_point)), 37, dunavant_rule_13 },
    { sizeof(dunavant_rule_14)/(sizeof(dunavant_point)), 42, dunavant_rule_14 },
    { sizeof(dunavant_rule_15)/(sizeof(dunavant_point)), 48, dunavant_rule_15 },
    { sizeof(dunavant_rule_16)/(sizeof(dunavant_point)), 52, dunavant_rule_16 },
    { sizeof(dunavant_rule_17)/(sizeof(dunavant_point)), 61, dunavant_rule_17 },
    { sizeof(dunavant_rule_18)/(sizeof(dunavant_point)), 70, dunavant_rule_18 },
    { sizeof(dunavant_rule_19)/(sizeof(dunavant_point)), 73, dunavant_rule_19 },
    { sizeof(dunavant_rule_20)/(sizeof(dunavant_point)), 79, dunavant_rule_20 },
    { 0, 0, NULL }
};

template<typename T>
std::vector<quadrature_point<T,2>>
triangle_quadrature_dunavant(const point<T,2>& p0,
                             const point<T,2>& p1,
                             const point<T,2>& p2,
                             size_t degree)
{
    auto max_degree = sizeof(dunavant_rules)/sizeof(dunavant_rule);
    if (degree > max_degree)
        throw std::invalid_argument("Dunavant quadrature: degree too high");

    size_t rule_num = (degree == 0) ? 0 : degree - 1;
    assert(rule_num < max_degree-1);

    auto v0 = p1 - p0;
    auto v1 = p2 - p0;
    auto area = std::abs( (v0.x() * v1.y() - v0.y() * v1.x())/2.0 );

    auto num_entries = detail::dunavant_rules[rule_num].num_entries;
    auto num_points = detail::dunavant_rules[rule_num].num_points;

    std::vector<quadrature_point<T,2>> ret;
    ret.reserve(num_points);

    for (size_t i = 0; i < num_entries; i++)
    {
        auto& dp = detail::dunavant_rules[rule_num].points[i];
        
        auto l0 = dp.coords[0];
        auto l1 = dp.coords[1];
        auto l2 = dp.coords[2];
        auto w = dp.weight;
        
        switch (dp.perms)
        {
            case 1:
                ret.push_back({p0*l0 + p1*l1 + p2*l2, w*area});
                break;
                
            case 3:
                ret.push_back({p0*l0 + p1*l1 + p2*l2, w*area});
                ret.push_back({p0*l1 + p1*l2 + p2*l0, w*area});
                ret.push_back({p0*l1 + p1*l0 + p2*l2, w*area});
                break;
            
            case 6:
                ret.push_back({p0*l0 + p1*l1 + p2*l2, w*area});
                ret.push_back({p0*l0 + p1*l2 + p2*l1, w*area});
                ret.push_back({p0*l1 + p1*l0 + p2*l2, w*area});
                ret.push_back({p0*l1 + p1*l2 + p2*l0, w*area});
                ret.push_back({p0*l2 + p1*l0 + p2*l1, w*area});
                ret.push_back({p0*l2 + p1*l1 + p2*l0, w*area});
                break;
        }
    }

    return ret;
}
/*
void print_rule_details(void)
{
    for (size_t i = 0; i < 7; i++)
    {
        std::cout << "Rule " << i+1 << std::endl;
        auto num_points = dunavant_rules[i].num_points;

        double tot_w = 0;

        for (size_t j = 0; j < num_points; j++)
        {
            auto l0 = dunavant_rules[i].data[j][0];
            auto l1 = dunavant_rules[i].data[j][1];
            auto l2 = dunavant_rules[i].data[j][2];
            auto w = dunavant_rules[i].data[j][3];
            tot_w += w;
            std::cout << "Coord sum: " << l0 + l1 + l2 << std::endl;
        }
        std::cout << "Tot weight: " << tot_w << std::endl;
    }
}
 */

/* See Ern & Guermond - Theory and practice of FEM, pag 360. */
template<typename T>
std::vector<quadrature_point<T,2>>
triangle_quadrature_low_order(const point<T,2>& p0,
                              const point<T,2>& p1, 
                              const point<T,2>& p2, size_t deg)
{
    std::vector<quadrature_point<T,2>>   ret;
    auto v0 = p1 - p0;
    auto v1 = p2 - p0;
    auto area = std::abs( (v0.x() * v1.y() - v0.y() * v1.x())/2.0 );
    point<T,2>      qp;
    T               qw;
    T               a1 = (6. - std::sqrt(15.)) / 21;
    T               a2 = (6. + std::sqrt(15.)) / 21;
    T               w1 = (155. - std::sqrt(15.)) / 1200;
    T               w2 = (155. + std::sqrt(15.)) / 1200;
    switch(deg)
    {
        case 0:
        case 1:
            qw = area;
            qp = (p0 + p1 + p2)/3;      ret.push_back( make_qp(qp, qw) );
            return ret;
        case 2:
            qw = area/3;
            qp = p0/6 + p1/6 + 2*p2/3;  ret.push_back( make_qp(qp, qw) );
            qp = p0/6 + 2*p1/3 + p2/6;  ret.push_back( make_qp(qp, qw) );
            qp = 2*p0/3 + p1/6 + p2/6;  ret.push_back( make_qp(qp, qw) );
            return ret;
        case 3:
            qw = 9*area/20;
            qp = (p0 + p1 + p2)/3;      ret.push_back( make_qp(qp, qw) );
            qw = 2*area/15;
            qp = (p0 + p1)/2;           ret.push_back( make_qp(qp, qw) );
            qp = (p0 + p2)/2;           ret.push_back( make_qp(qp, qw) );
            qp = (p1 + p2)/2;           ret.push_back( make_qp(qp, qw) );
            qw = area/20;
            qp = p0;                    ret.push_back( make_qp(qp, qw) );
            qp = p1;                    ret.push_back( make_qp(qp, qw) );
            qp = p2;                    ret.push_back( make_qp(qp, qw) );
            return ret;
        case 4:
        case 5:
            qw = 9*area/40;
            qp = (p0 + p1 + p2)/3;      ret.push_back( make_qp(qp, qw) );
            qw = w1 * area;
            qp = a1*p0 + a1*p1 + (1-2*a1)*p2;   ret.push_back( make_qp(qp, qw) );
            qp = a1*p0 + (1-2*a1)*p1 + a1*p2;   ret.push_back( make_qp(qp, qw) );
            qp = (1-2*a1)*p0 + a1*p1 + a1*p2;   ret.push_back( make_qp(qp, qw) );
            qw = w2 * area;
            qp = a2*p0 + a2*p1 + (1-2*a2)*p2;   ret.push_back( make_qp(qp, qw) );
            qp = a2*p0 + (1-2*a2)*p1 + a2*p2;   ret.push_back( make_qp(qp, qw) );
            qp = (1-2*a2)*p0 + a2*p1 + a2*p2;   ret.push_back( make_qp(qp, qw) );
            return ret;
            
        default:
            throw std::invalid_argument("Triangle quadrature: requested order too high");
    }
    return ret;
}

} // namespace detail

template<typename T>
std::vector<std::pair<point<T, 1>, T>>
gauss_legendre(size_t degree)
{
    return detail::gauss_legendre_tab<T>(degree);
}

template<typename Mesh>
std::vector<quadrature_point<typename Mesh::coordinate_type,2>>
integrate(const Mesh& msh,
          const typename Mesh::face_type& fc,
          size_t degree)
{
    using T = typename Mesh::coordinate_type;
    std::vector<quadrature_point<T,2>> ret;
    auto raw_qps = gauss_legendre<T>(degree);
    auto meas = measure(msh, fc);
    auto pts  = points(msh, fc);

    for (auto itor = raw_qps.begin(); itor != raw_qps.end(); itor++)
    {
        auto raw_qp = *itor;
        auto t  = raw_qp.first.x();
        auto qp  = 0.5 * (1 - t) * pts[0] + 0.5 * (1 + t) * pts[1];
        auto qw  = raw_qp.second * meas * 0.5;

        ret.push_back({qp,qw});
    }

    return ret;
}

template<typename T>
std::vector<quadrature_point<T,2>>
integrate(const simplicial_mesh<T>& msh,
          const typename simplicial_mesh<T>::cell_type& cl,
          size_t degree)
{
#ifdef USE_DUNAVANT
    auto pts = points(msh, cl);
    return detail::triangle_quadrature_dunavant(pts[0], pts[1], pts[2], degree);
#else /* USE_DUNAVANT */
    auto pts = points(msh, cl);
    return detail::triangle_quadrature_low_order(pts[0], pts[1], pts[2], degree);
#endif /* USE_DUNAVANT */
}

template<typename T>
std::vector<quadrature_point<T,2>>
integrate(const refelem::reference_triangle<T>& t,
          size_t degree)
{
    return detail::triangle_quadrature_dunavant(t.points[0],
                                                t.points[1],
                                                t.points[2],
                                                degree);
}

/* Quadrature for cartesian quadrangles, it is just tensorized Gauss points. */
template<typename T>
std::vector<std::pair<point<T, 2>, T>>
quadrangle_quadrature(const size_t degree)
{
    auto qps = gauss_legendre<T>(degree);

    std::vector<std::pair<point<T, 2>, T>> ret;
    ret.reserve(qps.size() * qps.size());

    for (auto jtor = qps.begin(); jtor != qps.end(); jtor++)
    {
        auto qp_y = *jtor;
        auto eta  = qp_y.first.x();

        for (auto itor = qps.begin(); itor != qps.end(); itor++)
        {
            auto qp_x = *itor;
            auto xi   = qp_x.first.x();

            auto qw2d = qp_x.second * qp_y.second;
            auto qp2d = point<T, 2>({xi, eta});

            ret.push_back({qp2d, qw2d});
        }
    }

    return ret;
}

template<typename T>
std::vector<quadrature_point<T, 2>>
integrate(const quad_mesh<T>& msh,
          const typename quad_mesh<T>::cell_type& cl,
          size_t degree)
{
    auto raw_qps = quadrangle_quadrature<T>(degree);

    std::vector<quadrature_point<T, 2>> ret;
    ret.reserve(raw_qps.size());

    auto pts = points(msh, cl);

    auto P = [&](T xi, T eta) -> T {
        return 0.25 * pts[0].x() * (1 - xi) * (1 - eta) +
               0.25 * pts[1].x() * (1 + xi) * (1 - eta) +
               0.25 * pts[2].x() * (1 + xi) * (1 + eta) +
               0.25 * pts[3].x() * (1 - xi) * (1 + eta);
    };

    auto Q = [&](T xi, T eta) -> T {
        return 0.25 * pts[0].y() * (1 - xi) * (1 - eta) +
               0.25 * pts[1].y() * (1 + xi) * (1 - eta) +
               0.25 * pts[2].y() * (1 + xi) * (1 + eta) +
               0.25 * pts[3].y() * (1 - xi) * (1 + eta);
    };

    auto J = [&](T xi, T eta) -> T {
        auto j11 = 0.25 * ( (pts[1].x() - pts[0].x()) * (1 - eta) +
                            (pts[2].x() - pts[3].x()) * (1 + eta) );

        auto j12 = 0.25 * ( (pts[1].y() - pts[0].y()) * (1 - eta) +
                            (pts[2].y() - pts[3].y()) * (1 + eta) );

        auto j21 = 0.25 * ( (pts[3].x() - pts[0].x()) * (1 - xi) +
                            (pts[2].x() - pts[1].x()) * (1 + xi) );

        auto j22 = 0.25 * ( (pts[3].y() - pts[0].y()) * (1 - xi) +
                            (pts[2].y() - pts[1].y()) * (1 + xi) );

        return std::abs(j11 * j22 - j12 * j21);
    };

    for (auto& raw_qp : raw_qps)
    {
        auto xi  = raw_qp.first.x();
        auto eta = raw_qp.first.y();

        auto px = P(xi, eta);
        auto py = Q(xi, eta);

        auto qw = raw_qp.second * J(xi, eta);
        auto qp = point<T, 2>({px, py});
        ret.push_back({qp, qw});
    }

    return ret;
}

} // namespace quadratures
} // namespace yaourt
